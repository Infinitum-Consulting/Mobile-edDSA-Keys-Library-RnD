Dec 11, 2024 - 12:09 IST

1. Android Keystore system 

Key chain API 
Android Keystore provider

Use the KeyChain API when you want system-wide credentials. When an app requests the use of any credential through the KeyChain API, users can choose, through a system-provided UI, which of the installed credentials an app can access. This lets several apps use the same set of credentials with user consent.

Use the Android Keystore provider to let an individual app store its own credentials, which only that app can access. This provides a way for apps to manage credentials that only they can use while providing the same security benefits that the KeyChain API provides for system-wide credentials. This method doesn't require the user to select the credentials.

 Open Source Custodial Wallet - krakenfx
 https://github.com/krakenfx/wallet/blob/main/src/screens/Settings/walletBackup/components/WalletBackupVerify.tsx

Keychain interaction as resetting the generic password or verifying it 
https://github.com/krakenfx/wallet/blob/main/src/secureStore/keychain/index.ts 

Generating public-private key using keystore in android 
https://yggr.medium.com/how-to-generate-public-private-key-in-android-7f3e244c0fd8

Secured keychain provider for kraken wallet 
https://github.com/krakenfx/wallet/blob/main/src/secureStore/SecuredKeychainProvider.tsx

SecuredKeychainProvider
 A React context provider that manages secure retrieval of sensitive cryptographic information:

## Main Responsibilities:
- Provides methods to retrieve mnemonics and seeds
- Implements a security workflow for accessing sensitive data
- Handles different authentication scenarios

## Key Methods

-- getSecuredValue()
Central method for retrieving sensitive information
Handles different authentication scenarios
Manages the retrieval process dynamically

-- checkPassword()
Validates user-entered password
Retrieves secret if password is correct
Manages lockout and error states
Secure Retrieval Methods

-- getMnemonic()
Retrieves wallet recovery phrase
Optional error handling
Requires authentication if seed is protected

-- getSeed()
Retrieves cryptographic seed
Converts hex string to ArrayBuffer
Requires a rationale for access
Supports optional error throwing


Dec 12, 2024 - 12:09 IST

Keystore provides the following categories of operations:

Key generation
Import and export of asymmetric keys (no key wrapping)
Import of raw symmetric keys (no key wrapping)
Asymmetric encryption and decryption with appropriate padding modes
Asymmetric signing and verification with digesting and appropriate padding modes
Symmetric encryption and decryption in appropriate modes, including an AEAD mode
Generation and verification of symmetric message authentication codes

## Another Method of storing the keys 
 
Hardware-Backed Trusted Execution Environment (TEE)

What it is: Use a Secure Element (SE) or Trusted Execution Environment (TEE) to store keys securely at the hardware level.

Why it's secure:
The keys never leave the hardware and are isolated from the OS.
Access to keys is only allowed for cryptographic operations.
Example: Use StrongBox with the Keystore to leverage hardware-backed key storage


Alternatives of storing keys in android keystore system 
- Encrypted Shared Preferences
- Database Encryption
- File Encryption
- Cloud Storage
- Native Encryption


Dec 13, 2024 - 19:27 IST

### expo-secure-store implementation and comparison with Android keystore system 

https://docs.expo.dev/versions/latest/sdk/securestore/

Expo SecureStore and Android Keystore System are both used for securely storing sensitive information, such as passwords or encryption keys, on mobile devices.
However, they differ in how they interact with the underlying hardware and software to provide this security, as well as in their capabilities and the platforms they support.


** why we can't use Expo SecureStore for cryptographic process:

- Cross-platform solution for both iOS and Android.
- On Android, it uses SharedPreferences with encryption and wraps the Android Keystore for encryption and decryption.
- On iOS, it uses Keychain Services, which is Apple's secure storage system.
- It does not guarantee hardware-backed security for key storage on Android devicesâ€”its security relies on the encryption methods provided by the Android OS.
- Focuses on securely storing and retrieving simple data such as strings (passwords, tokens, etc.).
- Does not provide advanced key management operations (e.g., key generation, signing, etc.) but can store keys safely in a database or secure storage after they are generated.
- Best used for storing sensitive data (e.g., user credentials, tokens) where hardware-level security is not strictly necessary.
- Suitable for apps where hardware-backed key storage is not a requirement, but encrypted storage is still needed for storing user data securely.
- Does not guarantee hardware-backed storage for keys on Android. It typically uses software-backed encryption, although it can integrate with the Android Keystore for encryption on Android devices.


** why we need to use Android Keystore system for cryptographic process:

- Provides a secure hardware-backed container for storing cryptographic keys and performing cryptographic operations (like signing and encryption).
- Hardware-backed security: On devices with a trusted execution environment (TEE) or a secure element (SE), the Android Keystore can store cryptographic keys in hardware, making them more secure from attacks such as rooting or physical extraction.
- Keys are never exposed to the app, and cryptographic operations are done directly on the hardware 
- Allows for generation, storage, and management of cryptographic keys directly within the Keystore, with operations like signing, encryption, decryption, and key attestation being supported.
- Provides hardware-backed security for storing and using cryptographic keys.

Dec 15, 2024 16:49 IST

Expo secure store implementation, it's code sampless:

1. installation of library as expo-secure-store for secureStore and ed25519,expo-crypto for generating keys: 

import * as SecureStore from 'expo-secure-store';
import * as ed25519 from '@noble/ed25519';
import { getRandomBytes } from 'expo-crypto';
import { sha512 } from '@noble/hashes/sha512';

2. Storing keys as key-value pairs in secureStore and storing the signature 

await SecureStore.setItemAsync('privateKey', privateKeyHex);
await SecureStore.setItemAsync('publicKey', publicKeyHex);
await SecureStore.setItemAsync('signature', signatureHex);

3. Retrieve key stores by the name stored in store and getting the signature 
  
const storedPrivateKey = await SecureStore.getItemAsync('privateKey');
const storedPublicKey = await SecureStore.getItemAsync('publicKey');
const storedSignature = await SecureStore.getItemAsync('signature');

4. signing the signature using ed25519 

const privateKeyBuffer = getRandomBytes(32);
const publicKeyBuffer = await ed25519.getPublicKey(privateKeyBuffer);

const privateKeyHex = Buffer.from(privateKeyBuffer).toString('hex');
const publicKeyHex = Buffer.from(publicKeyBuffer).toString('hex');

      // Sign the message
const messageBuffer = Buffer.from(message);
const signatureBuffer = await ed25519.sign(messageBuffer, privateKeyBuffer);
const signatureHex = Buffer.from(signatureBuffer).toString('hex');



Dec 16, 2024 13:15 IST

React Native research for getting the best security for using Android Keystore

Understanding with using React-native-keychain (https://oblador.github.io/react-native-keychain/docs/secure-hardware-vs-software)

Android uses two primary levels of security for cryptographic key storage and operations:

1.Secure Hardware (StrongBox Keymaster)
2.Secure Software (Trusted Execution Environment)

What is Secure Hardware (StrongBox Keymaster)?
Secure Hardware refers to a dedicated, physically isolated security chip (e.g., StrongBox). It is designed to provide the highest level of security for cryptographic key operations.

Key Features of Secure Hardware:
1. Hardware Isolation: The cryptographic keys are stored in a secure, tamper-resistant environment that is completely isolated from the main device's operating system and CPU.

2. Hardware-backed Security: Cryptographic operations (like signing or encryption) are performed directly on the hardware, ensuring that the keys never leave the secure environment.

3. Resistant to Physical Attacks: Designed to thwart physical attacks like voltage manipulation or side-channel attacks.

4. StrongBox Support: Devices with Android 9 (API Level 28) or higher may include StrongBox, which enhances hardware-backed security.


What is Secure Software (TEE)?
Secure Software refers to the Trusted Execution Environment (TEE), a secure area of the device's main processor. It provides a sandboxed environment to store and process cryptographic keys securely, but it is not physically isolated like Secure Hardware.

Key Features of TEE:
1. Software Isolation: The TEE is a secure part of the main CPU that runs a separate, trusted OS to handle sensitive operations.

2. Secure Key Storage: Cryptographic keys are stored in the TEE and are protected from the main operating system and apps.
Widely Available: Most Android devices support TEE-based security, even if they lack dedicated Secure Hardware.

## How Does It Affect react-native-keychain?
When using react-native-keychain on Android, the library relies on the Android KeyStore system to store and manage cryptographic keys. The level of security provided depends on the device and its capabilities:

1. StrongBox Enabled Devices: If a device supports StrongBox, react-native-keychain can store keys in the Secure Hardware, offering the highest level of security.

2. TEE-Only Devices: If StrongBox is not available, the keys are stored in the TEE, which is still secure but less resistant to physical attacks.


Dec 17, 2024 21:39 IST

# Implementing Secure Key Storage with React Native Keychain

1.Generate an ED25519 cryptographic key pair (using tweetnacl library).
2.Store the keys securely in the Android Keystore using react-native-keychain.
3.Retrieve the stored keys securely when needed.
4.Delete the stored keys if required.


# Technologies Used

1. React Native: Framework for building mobile applications.
2. react-native-keychain: Secure storage library for credentials.
3. tweetnacl and tweetnacl-util: Cryptographic library for key generation and encoding.


1. Setup and Installation

npm install react-native-keychain tweetnacl tweetnacl-util

2. Generating and Storing ED25519 Keys

 const keyPair = nacl.sign.keyPair();

    //  Encode keys to Base64 for safe storage
    const publicKeyBase64 = naclUtil.encodeBase64(keyPair.publicKey);
    const privateKeyBase64 = naclUtil.encodeBase64(keyPair.secretKey);

    //  Store the private key securely using Keychain
    await Keychain.setGenericPassword(publicKeyBase64, privateKeyBase64, {
      accessible: Keychain.ACCESSIBLE.WHEN_UNLOCKED_THIS_DEVICE_ONLY,
      securityLevel: Keychain.SECURITY_LEVEL.SECURE_HARDWARE, // Enforce hardware-backed storage
    });

3. Retrieving Stored Keys

const credentials = await Keychain.getGenericPassword();

4. Deleting Stored Keys

await Keychain.resetGenericPassword(); // Deletes credentials

5. Verifying Security Level

 const checkSecurityLevel = async () => {
  const securityLevel = await Keychain.getSecurityLevel();
  console.log('Security Level:', securityLevel);
};

SECURITY_LEVEL.SECURE_HARDWARE: Hardware-backed secure storage is used.
SECURITY_LEVEL.SECURE_SOFTWARE: Software-based encryption is used.


Dec 18, 2024 02:01 IST 

Security of SECURE_SOFTWARE:

Encryption within the app: Keys are encrypted and stored within the app's sandbox (the internal storage of the device). The encryption is software-based, which means that it relies on the operating system and app's security mechanisms to prevent unauthorized access.

Vulnerabilities:

a. Rooted/jailbroken devices: On rooted or jailbroken devices, attackers can gain access to the app's storage and potentially extract the cryptographic keys, because the OS security mechanisms are bypassed. The key storage is not isolated by hardware security, and attackers can use tools to access or dump the app's data.
b. Physical access: If an attacker gains physical access to the device (e.g., by accessing the device directly or via malware), extracting the keys from software storage is possible, especially if the device is not properly secured (e.g., with a strong PIN or encryption).
Limited by OS security: Software-based encryption relies on the operating system's security features, such as:

App sandboxing, which isolates your appâ€™s data from other apps.
Encryption within the app that can be protected by a password or biometric (but only when the device is locked).


Security of SECURE_HARDWARE:

Hardware-backed security (e.g., using Android Keystore, Trusted Execution Environment, or a Secure Element) provides significantly stronger protection because the cryptographic keys never leave the secure hardware. The keys are stored in a tamper-resistant module that is not accessible even by the OS, and the key operations (e.g., signing) occur inside the secure hardware, making it much harder for an attacker to extract the keys.


Dec 18, 2024 13:06 IST 

Rotate Keys in android keystore in react native environment:

    const newKeyPair = nacl.sign.keyPair();

    // 2. Encode keys to Base64 for safe storage
    const newPublicKeyBase64 = naclUtil.encodeBase64(newKeyPair.publicKey);
    const newPrivateKeyBase64 = naclUtil.encodeBase64(newKeyPair.secretKey);

    // 3. Store the new private key securely using Keychain
    await Keychain.setGenericPassword(newPublicKeyBase64, newPrivateKeyBase64, {
      accessible: Keychain.ACCESSIBLE.WHEN_UNLOCKED_THIS_DEVICE_ONLY,
      securityLevel: Keychain.SECURITY_LEVEL.SECURE_HARDWARE, // Use hardware-backed storage
    });

    // 4. Optionally, delete the old key pair if it exists
    await Keychain.resetGenericPassword();


## Purpose of jubjub and ed25519:

Ed25519:

1. It is primarily used for digital signatures.
2. Designed as part of the EdDSA (Edwards-curve Digital Signature Algorithm) for fast, secure, and efficient public-key signing.
3. It is widely used in applications like SSH, TLS, and modern cryptographic protocols.
4. Very fast for public key cryptography operations like signing and verification.
5. Widely used in mainstream cryptography because of its efficiency on general-purpose CPUs.

Jubjub:

1. Designed specifically for zero-knowledge proofs and zk-SNARKs, such as those used in privacy-preserving blockchain technologies (e.g., Zcash).
2. Optimized to work efficiently within the context of arithmetic circuits and zk-SNARKs.
3. Jubjub is not typically used for digital signatures outside zero-knowledge systems.
4. Optimized for use in zero-knowledge circuits where operations (like addition and scalar multiplication) must be cheap in terms of "circuit constraints" (low number of gates in arithmetic circuits).
5. Not as fast as Ed25519 for traditional cryptographic operations but outperforms Ed25519 in the context of zero-knowledge proofs.
